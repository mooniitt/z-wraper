'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var _regeneratorRuntime = _interopDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator = _interopDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var rollupPluginutils = require('rollup-pluginutils');
var path = require('path');
var fsExtra = require('fs-extra');
var less = _interopDefault(require('less'));
var CleanCSS = _interopDefault(require('clean-css'));

var cwd = process.cwd();
var SOURCEMAP_INLINE = 'inline';
/**
 * Rollup plugin less modules provides the ability to import less content directly into the es module
 * @param {Object} options The plugin options
 * @param {(boolean|string)=} options.output Should the compiled styles be bundled to a separate css file, can be used to override the destination file path
 * @param {(boolean|string)=} options.sourcemap If true, a separate sourcemap file will be created. If inline, the sourcemap will be appended to the resulting output file as a data URI
 * @param {boolean=} options.minify Controls the minification of the resulting CSS content
 * @param {Function=} options.processor A callback function that when provided will be invoked with compiled CSS to perform additional transformations before the generate phase
 * @param {Object=} options.options The options to be provided to LESS while rendering the less files
 * @returns {Object}
 */

function index () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var pluginOptions = Object.assign({
    output: false,
    sourcemap: true,
    minify: false,
    processor: null,
    options: {}
  }, options);
  var generateSourceMaps = !!pluginOptions.sourcemap;
  var inlineSourceMaps = pluginOptions.sourcemap === SOURCEMAP_INLINE;
  var filter = rollupPluginutils.createFilter(pluginOptions.include || ['**/*.less', '**/*.css'], pluginOptions.exclude || 'node_modules/**');
  var rollupInput = null;
  /**
   * A hash of compiled styles
   */

  var styles = {};
  /**
   * List of paths for lessJS to resolve the imports
   * @type {Set}
   */

  var pathsSet = new Set([cwd]);
  /**
   * Replaces the file extension in the provided path
   * @param {string} filePath The file path
   * @param {string} fileExtension The file extension
   * @returns {string|null}
   */

  var toFileExtension = function toFileExtension(filePath, fileExtension) {
    return filePath && filePath.replace(path.extname(filePath), fileExtension) || null;
  };
  /**
   * Renders a less file source
   * @param {string} source The less file source
   * @param {string} filename The file relative path
   * @returns {css, map, imports}
   */


  var lessRender = function lessRender(source, filename) {
    var paths = Array.from(pathsSet);
    return less.render(source, Object.assign({
      paths: paths,
      filename: filename,
      sourceMap: {}
    }, pluginOptions.options));
  };
  /**
   * Minifies several css sources
   * @param {Object} minifySources An object with the keys as module Ids, and values objects like {styles, sourceMap}
   * @returns {Promise.<{css: string, map: string}>}
   */


  var minifyCss =
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee(minifySources) {
      var output;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return new CleanCSS({
                sourceMap: true,
                returnPromise: true
              }).minify(minifySources);

            case 2:
              output = _context.sent;
              return _context.abrupt("return", {
                css: "".concat(output.styles),
                map: "".concat(output.sourceMap)
              });

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function minifyCss(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  /**
   * Invokes the user defined post process function
   * @param {Object} iOutput An object having the less render output signature
   * @param {string} id The path to the less file
   * @returns {Promise.<{css: string, map: string}>}
   */


  var doPostProcess =
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee2(iOutput, id) {
      var output, processedOutput;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              output = iOutput;

              if (!(typeof pluginOptions.processor === 'function')) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return pluginOptions.processor(iOutput, id);

            case 4:
              _context2.t0 = _context2.sent;
              _context2.next = 8;
              break;

            case 7:
              _context2.t0 = iOutput;

            case 8:
              processedOutput = _context2.t0;

              if (processedOutput.css && processedOutput.map) {
                output = processedOutput;
              } else {
                _this.warn('Rollup less modules plugin ignored processor output due to an invalid return value');
              }

              return _context2.abrupt("return", output);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function doPostProcess(_x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * Extends the less render output with an es-module export code
   * @param {css, map} output
   * @param {string} id
   * @returns {css, map, code}
   */


  var injectModuleExports = function injectModuleExports(output, id) {
    var map = typeof (output.map || {
      mappings: ''
    }) === 'string' ? JSON.parse(output.map) : output.map;
    var styles = output.css; // Inlines the source-maps into the styles exported as es-module

    if (inlineSourceMaps) {
      styles = "".concat(styles, "\n").concat(getInlineSourceMapContent(map));
    }

    var dependencies = (output.imports || []).map(function (importee) {
      return path.join(path.relative(path.dirname(id), path.dirname(importee)), path.basename(importee));
    }); // TODO check for new rollup API addWatchFile
    // Generate the es-module dependencies based on the less imports to allow rollup watch detect changes in the dependent files
    // The proper rollup API fix for this behaviour still pending {@link https://github.com/rollup/rollup/issues/1203}

    var codeImports = dependencies.reduce(function (src, importee) {
      return "".concat(src, "import \".").concat(path.sep + importee, "\";\n");
    }, '');
    var codeExports = "export default ".concat(JSON.stringify(styles), ";\nexport const sourceMap = ").concat(JSON.stringify(map), ";");
    var code = "".concat(codeImports, "\n").concat(codeExports);
    return Object.assign(output, {
      code: code,
      map: map
    });
  };
  /**
   * Performs the sequence of less rendering, minification and post processing of a less source
   * @param {string} source The less file content
   * @param {string} id The less file path
   * @returns {Promise.<css|map|imports>}
   */


  var _transform =
  /*#__PURE__*/
  function () {
    var _ref3 = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee3(source, id) {
      var filename, output, minifySources;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              filename = path.relative(cwd, id);
              _context3.next = 3;
              return lessRender(source, filename);

            case 3:
              output = _context3.sent;
              output.map = output.map ? JSON.parse(output.map) : output.map; // Minify

              if (!pluginOptions.minify) {
                _context3.next = 13;
                break;
              }

              minifySources = _defineProperty({}, id, {
                styles: output.css,
                sourceMap: output.map
              });
              _context3.t0 = Object;
              _context3.t1 = output;
              _context3.next = 11;
              return minifyCss(minifySources);

            case 11:
              _context3.t2 = _context3.sent;
              output = _context3.t0.assign.call(_context3.t0, _context3.t1, _context3.t2);

            case 13:
              if (!pluginOptions.processor) {
                _context3.next = 17;
                break;
              }

              _context3.next = 16;
              return doPostProcess(output, id);

            case 16:
              output = _context3.sent;

            case 17:
              return _context3.abrupt("return", output);

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    return function transform(_x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  }();
  /**
   * Generates the content of a sourceMap ready to be appended to the CSS content
   * @param {Object} sourceMap The sourceMap object
   * @returns {string} The content of the inlined sourceMap
   */


  var getInlineSourceMapContent = function getInlineSourceMapContent(sourceMap) {
    var sStringMap = typeof sourceMap === 'string' ? sourceMap : JSON.stringify(sourceMap);
    var smBase64 = Buffer.from(sStringMap).toString('base64');
    return "/*# sourceMappingURL=data:application/json;base64,".concat(smBase64, " */");
  };

  var resolveCssBundlePath = function resolveCssBundlePath(outputOptions) {
    var outputBundleFile = outputOptions.file;
    var outputBundleDir = outputOptions.dir;
    var inputFileName = path.basename(rollupInput); // Uses this plugin override CSS bundle path if provided

    if (typeof pluginOptions.output === 'string') {
      return pluginOptions.output;
    } // Write the CSS file in the same path as the bundle file


    if (outputBundleFile) {
      return toFileExtension(outputBundleFile, '.css');
    } // Output the CSS file to the configured multi chunk directory using the input file name


    return toFileExtension(path.join(outputBundleDir, inputFileName), '.css');
  };

  return {
    name: 'less-modules',
    options: function options(inputOptions) {
      rollupInput = inputOptions.input || this.warn('Expecting entry file to be defined on the InputOptions#input');
    },
    transform: function transform(source, id) {
      return _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (filter(id)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", null);

              case 2:
                // Store all the less file directories for less renderer to resolve relative paths
                pathsSet.add(path.dirname(id));
                _context4.t0 = injectModuleExports;
                _context4.next = 6;
                return _transform(source, id);

              case 6:
                _context4.t1 = _context4.sent;
                _context4.t2 = id;
                styles[id] = (0, _context4.t0)(_context4.t1, _context4.t2);
                return _context4.abrupt("return", {
                  code: styles[id].code,
                  map: styles[id].map
                });

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }))();
    },
    generateBundle: function generateBundle(outputOptions, bundleObject, isWrite) {
      var _this2 = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee5() {
        var destinationFile, destinationDir, cssBundlePath, lessBundlePath, cssMapsBundlePath, lessSources, transformOutput, cssBundleContent, cssBundleSourceMaps;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                destinationFile = outputOptions.file;
                destinationDir = outputOptions.dir;

                if (!(isWrite && pluginOptions.output && (destinationFile || destinationDir))) {
                  _context5.next = 25;
                  break;
                }

                cssBundlePath = resolveCssBundlePath(outputOptions);
                lessBundlePath = toFileExtension(cssBundlePath, '.less');
                cssMapsBundlePath = "".concat(cssBundlePath, ".map");

                if (cssBundlePath) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return");

              case 8:
                _context5.prev = 8;
                fsExtra.ensureFileSync(cssBundlePath);
                _context5.next = 16;
                break;

              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](8);

                _this2.error(_context5.t0);

                return _context5.abrupt("return");

              case 16:
                // Generate a less file that imports all the required less modules in the bundle
                lessSources = Object.keys(styles).reduce(function (src, id) {
                  return "".concat(src ? src + '\n' : src, "@import '").concat(path.relative(path.dirname(lessBundlePath), id), "';");
                }, ''); // Transform the generated less file using same workflow as for the bundle imported less modules

                _context5.next = 19;
                return _transform(lessSources, lessBundlePath);

              case 19:
                transformOutput = _context5.sent;
                cssBundleContent = "".concat(transformOutput.css);
                cssBundleSourceMaps = transformOutput.map;

                if (generateSourceMaps) {
                  if (inlineSourceMaps) {
                    cssBundleContent += "\n".concat(getInlineSourceMapContent(cssBundleSourceMaps));
                  } else {
                    cssBundleContent += "\n/*# sourceMappingURL=".concat(path.basename(cssMapsBundlePath), " */"); // Write the source-map file

                    fsExtra.writeFileSync("".concat(cssMapsBundlePath), JSON.stringify(cssBundleSourceMaps), 'utf8');
                  }
                } // Write the LESS file used to generate the bundle CSS


                fsExtra.writeFileSync(lessBundlePath, lessSources, 'utf8'); // Write the CSS bundle file

                fsExtra.writeFileSync(cssBundlePath, cssBundleContent, 'utf8');

              case 25:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[8, 12]]);
      }))();
    }
  };
}

module.exports = index;
